## 关闭TCP连接的动作

重点关注半连接的状态，在绝大数情况下，TCP 连接都是先关闭一个方向，此时另外一个方向还是可以正常进行数据传输。

上述的半关闭实在优雅的关闭下，服务器端如果处理不好，就可能是粗暴的关闭方式，可能有信息未及时传输给客户端，造成信息的丢失。

### close函数

```
int close(int sockfd)
```

这个函数很简单，对已连接的套接字执行 close 操作就可以，若成功则为 0，若出错则为 -1。

当前函数会对套接字的引用计数-1，到0的时候释放，彻底关闭两个方向的流。这和share_ptr有点像。关于套接字的+1操作，其实fork产生子进程的时候，套接字就是一个+1的操作。

具体close操作如下：

1. 在输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常。
2. 在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常。

### shutdown

```
int shutdown(int sockfd, int howto)
```

对已连接的套接字执行 shutdown 操作，若成功则为 0，若出错则为 -1。

howto 是这个函数的设置选项，它的设置有三个主要选项：

+ SHUT_RD(0)：关闭连接的“读”这个方向，对该套接字进行读操作直接返回 EOF。从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。
+ SHUT_WR(1)：关闭连接的“写”这个方向，这就是常被称为”半关闭“的连接。此时，不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端。应用程序如果对该套接字进行写操作会报错。
+ SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向。

和close的差别还是有的：

1. close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源。
2. close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响。
3. close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文，这在我们打算关闭连接通知对端的时候，是非常重要的。

### 总结

1. close 函数只是把套接字引用计数减 1，未必会立即关闭连接
2. close 函数如果在套接字引用计数达到 0 时，立即终止读和写两个方向的数据传送。


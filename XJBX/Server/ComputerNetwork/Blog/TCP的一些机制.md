## TCP的一些机制

TCP通过一些机制实现了可靠性的传输，这个可靠是通过序列号，确认应答，重发控制，连接管理，以及窗口等机制来实现可靠传输的。

### 重传

确认应答丢失的问题，丢包下，会启用重传的机制

1. 超时重传
2. 快速重传
3. SACK
4. D-SACK

超时重传比较简单，就是发送端会设置定时器，指定时延之后没有收到ACK下会重发该数据，在数据包丢失和确认应答丢失下都会发生重传

超时的时间（RTO）一般要和RTT（往返时延）关联起来，不应该过大和过小。

具体计算RTO的值会有指导公式

而快速重传，主要是数据驱动的。

快速重传的方式就是连续收到三个一样的ACK的时候就会重传

SACK就是对于前面快速重传机制的一些优化，可以选择性的只重传丢失的报文。

### 滑动窗口

在这个窗口内，无需等待确认应答，而可以继续发送数据的。

实际的实现就是系统开辟一个缓冲区，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已经发送的数据，收到了应答才能移除缓冲区

TCP头中的窗口大小其实就是接收端告诉发送端，还有多少的缓冲区可以接受数据，发送端参考这个数值去指定发送数据大小。

可用窗口的实际大小就是：

```
SND.WND -（SND.NXT - SND.UNA）
```

其中，SND.WND表示发送窗⼝的大小（大小是由接收⽅指定的），SND.UNA是一个绝对指针，指向已发送给但没有收到确认的第一个字节号，SND.NXT指向未发送但处于发送范围的第一个指针。

### 流量控制



### 拥塞控制

这里的拥塞主要是从网络环境来考量的

网络环境不行的时候，大量数据包可能会造成丢包和时延等情况，重传的话会进一步造成拥塞。拥塞控制就是为了避免这种情况。

实际的发送中，有一个拥塞窗口的概念，实际的TCP窗口值是拥塞窗口和接受窗口中的较小值。

关于拥塞控制算法，主要有四个：

+ 慢启动
+ 拥塞避免
+ 拥塞发生
+ 快速恢复

#### 慢启动

当发送方每收到⼀个 ACK，拥塞窗口 cwnd 的大小就会加 1。

这是一个指数增加的过程（1 - 2 - 4 - 8），会收到窗口所有的ack回复

当到达慢启动门限的时候，ssthresh，就会改用拥塞避免算法

#### 拥塞避免

⼀般来说ssthresh 的大小是65535字节。进入当前环节之后，没收到一个ack，cwnd增加1/4  cwnd

触发了重传的时候直接进入拥塞发生

#### 拥塞发生

+ 超时重传
+ 快速重传

这两种拥塞发送算法是不一样的。

发生超时重传的时候：

+ ssthresh设置为cwnd/2
+ cwnd设置为1

之后重新开始慢启动，这基本等于一脚刹车回到1档起步

另外的就是快速重传的那种，

+ cwnd = cwnd / 2
+ ssthresh = cwnd
+ 进入快速恢复算法

#### 快速恢复算法

还是之前拥塞发生的时候更新的cwnd和ssthresh的值

和快速重传一起使用，一般步骤如下：

1. 拥塞窗口cwnd = ssthresh + 3
2. 丢包重传
3. 再收到重复的ack，cwnd + 1
4. 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说 明从 duplicated  ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊ 拥塞避免状态；




## 内存的虚拟化

早期的时候，一般操作系统都用的绝对内存（参考单片机），同一片内存运行两个程序应该是巨难的。

有一种解决方案就是运行一个进程的时候在内存，要中断切换的时候，把当前内存的信息持久化到磁盘上，之后要恢复现场的时候又回复回来，用jio想都知道这个效率有多低。

后来出现了进程间的隔离，让操作系统为每个进程分配一套虚拟地址，大家都在自己的地方玩，进水不犯河水。

虚拟地址最后访问到实际的绝对地址，操作系统来安排（MMU），这样内存里的东西还在内存，不必为了io妥协

### 地址空间

一个进程操作中能看到的内存空间就是他的地址空间，这是虚拟内存的第一大目标

+ 代码部分
+ 栈
+ heap
+ 一些其他的东西（静态变量等）

我在描述malloc的那篇文章中画了大概的内存分布

第二个目标就是效率，操作系统也会寻求硬件的支持(多级页表和TLB的部分看到的)。

第三个目标就是保护，就是操作系统不会被恶意的黑掉吧，不会被恶意进程所干掉吧，突然想到了用户态和内核态

### 内存接口

首先要知道内存的管理是两级的，你的进程推出的时候内存没有泄露，就是一位这是第一级内存分配

第二级就是malloc和free，这是操作系统交给程序的。从侧面也能理解到，内核的编写是要及其严谨的。

往往两种内存会被分配到，一种就是栈内存，另一种就是堆内存。栈一般都是操作系统自己去管理的，不要你去显示的释放和处理。函数推出之后，这些往往就狗带了。

需要生存周期比较长的就可能需要heap了。这里就是C和C++的优势和弱势的地方。这些申请和释放都需要coder自己去完成，我很赞成bj的一句话，C类语言给程序员最大的信任，你的能力和积累的习惯能够完成当前的要求。

```
int *x = (int *) malloc(sizeof(int));
```

这里堆栈的处理都在这一行上，首先在栈上会申请一个int大小的空间，，然后返回一个地址给int*，提供给你在栈上使用。

比较浮夸的是，一般都以为要有以下的include才能使用malloc

```
#include <stdlib.h>
```

其实在很多平台下是不需要的，加上这个头文件知识为了检测是否正确调用了这个参数。里面的参数是一个size_t类型，其中关于这个类型的问题，我在lseek上踩过坑，大概是int和size_t用混的，具体也不太记得了。传入数字的其实不多见，一般都是宏定义，或者sizeof。另外关于sizeof，其实这是一个关键字，所以你其实可以像下面这样用

```
memset(arry,0x3f,sizeof arry)
```

sizeof()好像才是一个函数。

另外大多数时候，sizeof只知道分配了多大的指针信息，但是

```
int x[N];
sizeof(x);
```

确实是全部的字节数，原因就是数组里提供了多余的静态信息。

最后，关于字符串，有一个好习惯就预留大一点的空间，因为结尾是有一个`/0`的

关于释放

```
free(x);
```

最后还有一些坑，例如strcpy，它里面的dst，是要提前分配空间的，不然也不知道他又多大，过的了编译也会报错。

其实完全可以善用goto语句，比如在END：的地方做一些空间释放判断和处理，在出现一些错误的时候goto END

最后之前写过malloc的简单实现，就是sbrk分配堆区的相关任务。

### 地址转换



### 分段




### 分页



### 最后的机制

